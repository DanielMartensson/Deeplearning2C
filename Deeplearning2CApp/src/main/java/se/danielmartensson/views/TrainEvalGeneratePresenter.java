package se.danielmartensson.views;
import com.gluonhq.charm.glisten.animation.BounceInRightTransition;
import com.gluonhq.charm.glisten.application.MobileApplication;
import com.gluonhq.charm.glisten.control.AppBar;
import com.gluonhq.charm.glisten.control.ProgressBar;
import com.gluonhq.charm.glisten.mvc.View;
import com.gluonhq.charm.glisten.visual.MaterialDesignIcon;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import org.deeplearning4j.nn.api.Layer;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.nd4j.evaluation.classification.Evaluation;
import org.nd4j.evaluation.regression.RegressionEvaluation;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.DataSet;
import org.nd4j.linalg.dataset.api.iterator.DataSetIterator;
import javafx.fxml.FXML;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.TextArea;
import javafx.scene.layout.RowConstraints;
import javafx.stage.Screen;
import se.danielmartensson.deeplearning.DL4JModel;
import se.danielmartensson.deeplearning.DL4JThread;
import se.danielmartensson.tools.Dialogs;
import se.danielmartensson.tools.FileHandler;
import se.danielmartensson.tools.SimpleDependencyInjection;

public class TrainEvalGeneratePresenter {

    @FXML
    private View view;

    @FXML
    private TextArea textArea;
    
    @FXML
    private ProgressBar progressBar;
    
    @FXML
    private RowConstraints gridPane0;

    @FXML
    private RowConstraints gridPane1;

    /*
     * Fields
     */
	private AppBar appBar;
	private Dialogs dialogs = new Dialogs();
	FileHandler fileHandler = new FileHandler();
	private DL4JModel dL4JModel;
	private AtomicBoolean continueLoop = new AtomicBoolean();
	private final String cPath = "/Deeplearning2CStorage/cgeneration/";
	
    @FXML
    void initialize() {
    	/*
		 * Dependency injection
		 */
    	dL4JModel = SimpleDependencyInjection.getDL4JModel();
    	
    	/*
    	 * Slide smooth in and out
    	 */
    	view.setShowTransitionFactory(BounceInRightTransition::new);
        
        /*
    	 * Listener for leaving and enter the page
    	 */
    	view.showingProperty().addListener((obs, oldValue, newValue) -> {
    		if (newValue) {
            	/*
                 * Enter the page
                 */
                appBar = MobileApplication.getInstance().getAppBar();
                appBar.setNavIcon(MaterialDesignIcon.MENU.button(e -> MobileApplication.getInstance().getDrawer().open()));
                appBar.setTitleText("Train Eval Generate");
                
                /*
                 * Listeners for appBar
                 */
                appBar.getActionItems().add(MaterialDesignIcon.BUILD.button(e -> trainModel()));
        		appBar.getActionItems().add(MaterialDesignIcon.BUSINESS.button(e -> evaluateModel()));
        		appBar.getActionItems().add(MaterialDesignIcon.COPYRIGHT.button(e -> generateCCode()));
        		
        		/*
        		 * Generate a model from the configuration when we slide in...if we have selected a model
        		 */
        		if(dL4JModel.getDL4JSerializableConfiguration().getModelName() == null)
        			dialogs.alertDialog(AlertType.INFORMATION, "Model", "No model where selected");
        		else
        			dL4JModel.generateModel();
        		
        		if(dL4JModel.getDL4JData().getTrainDataSetIterator() == null)
        			dialogs.alertDialog(AlertType.INFORMATION, "Data", "No training data has been selected");
    		}
    	});
    	
    	/*
		 * Change the progress bar to correct size
		 */
		double heightScreen = Screen.getPrimary().getBounds().getHeight();
		double widthScreen = Screen.getPrimary().getBounds().getWidth();
		view.setPrefSize(widthScreen, heightScreen);
		gridPane0.setPrefHeight(widthScreen*0.55);
		gridPane1.setPrefHeight(heightScreen*0.45);
		progressBar.setPrefSize(widthScreen, heightScreen*0.45);
		
    }

    /**
     * This method will generate C-code
     */
	private void generateCCode() {
		/*
		 * Do a quick check!
		 */
		if(dL4JModel.getDL4JSerializableConfiguration().getModelName() == null)
			return;
		
		/*
		 * Get local date
		 */
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
		LocalDateTime localDateTime = LocalDateTime.now();  
		String creationDate = dateTimeFormatter.format(localDateTime);
		
		/*
		 * Write header file
		 */
		String modelName = dL4JModel.getDL4JSerializableConfiguration().getModelName();
		String comment = "/*\n" + 
				" * Model: " + modelName + "\n\n" + 
				" *  Created on: " + creationDate + "\n" + 
				" *  	Generated by: Deeplearning2C\n" +
				" *     		Author: Daniel MÃ¥rtensson\n" + 
				" */\n\n";
		String ifndef = "#ifndef " + modelName.toUpperCase() + "_H_\n";
		String define = "#define " + modelName.toUpperCase() + "_H_\n\n";
		String function = "void " + modelName + "(float* input, float* output);\n\n";
		String endif = "#endif /* " + modelName.toUpperCase() + "_H_ */";

		/*
		 * Write .h file now
		 */
		String absolutPath = cPath + modelName + "/" + modelName + ".h";
		fileHandler.writeTextTo(absolutPath, comment + ifndef + define + function + endif);
		
		/*
		 * Write .c file now - Write the includes
		 */
		String include = "#include " + "\"" + modelName + ".h\"\n";
		include += "#include \"BLAS/f2c.h\"\n";
		include += "#include \"BLAS/functions.h\"\n\n";
		
		/*
		 * Write function name
		 */
		String functionStart = "void " + modelName + "(float* input, float* output){\n\n";
		
		/*
		 * Write the blas parameters
		 */
		String blasParameters = "\tinteger m = 0; // Real row dimension of non-transpose A\n" + 
				"\tinteger n = 0; // Read column dimension of non-transpose A\n" + 
				"\treal alpha = 1; // Always 1\n" + 
				"\treal beta = 1; // Always 1\n" + 
				"\tinteger incx = 1; // Always 1\n" + 
				"\tinteger incy = 1; // Always 1\n" + 
				"\tchar trans = 'N'; // We have transpose matrix A'\n\n";
		
		/*
		 * Write the arrays - Get layers
		 */
		String arrays = "\t/*\n" + 
				"\t * We are using BLAS subroutine sgemv for solving y = alpha*A*x + beta*y\n" + 
				"\t * The BLAS subroutine is the same routine that is used in EmbeddedLapack\n" + 
				"\t * Solve the equations like:\n" + 
				"\t * b0 = act(W0*input + b0)\n" + 
				"\t * b1 = act(W1*b0 + b1)\n" + 
				"\t * b2 = act(W2*b1 + b2)\n" + 
				"\t * b3 = act(W3*b2 + b3)\n" + 
				"\t * b4 = act(W4*b3 + b4)\n" + 
				"\t * ....\n" + 
				"\t * ....\n" + 
				"\t * output = act(Wi*b(i-1) + bi)\n" + 
				"\t */\n\n";
		
		int totalLayers = dL4JModel.getMultiLayerNetwork().getnLayers();
		ArrayList<Activation> activationList = dL4JModel.getDL4JSerializableConfiguration().getActivationList();
		for(int i = 0; i < totalLayers; i++) {
			Layer layer = dL4JModel.getMultiLayerNetwork().getLayer(i);
			Map<String, INDArray> weights = layer.paramTable();
			//System.out.println(weights.keySet());
			
		    /*
		     * Notice that the current version of Deeplearning2C can only
		     * generate DenseLayer to C-code. In other words, MLP to C-code. 
	   	     * It's because DL4J have not yet make so LSTM weights are not available already, 
		     * as I understand them. But the goal is to make LSTM available for C-code generation.
		     */
			
			/*
			 * We need to reverse [W, b] to [b, W] because we use W's dimensions last for BLAS
			 */
			List<String> list = new ArrayList<>(weights.keySet());
			Collections.reverse(list);
				
			/*
			 * Print out matrix
			 */
			int totalColumns = 0;
			int totalRows = 0;
			for(String name : list) { 
				INDArray matrix = weights.get(name);
				totalRows = matrix.rows();
				totalColumns = matrix.columns();
				arrays += "\treal " + name + i + "["+totalRows+"*"+totalColumns+"]=";
				String firstPart = matrix.toString().replace("[", ""); // Just replace [ to "" and ] to ""
				String secondPart = firstPart.replace("]", "");
				secondPart = "{" + secondPart + "}"; // Now we got a C-array
				arrays += secondPart.replace("\n", "\n\t\t\t\t "); // This like make the matrices symmetrical
				arrays += ";\n";
			}
			/*
			 * For every complete list iteration, we have all matrices and vectors
			 * Solve the equations like:
			 * b0 = act(W0*input + b0)
			 * b1 = act(W1*b0 + b1)
			 * b2 = act(W2*b1 + b2)
			 * b3 = act(W3*b2 + b3)
			 * b4 = act(W4*b3 + b4)
			 * ....
			 * ....
			 * output = act(Wi*b(i-1) + bi)
			 */
			arrays += "\tm = " + totalColumns + ";\n";
			arrays += "\tn = " + totalRows + ";\n";
			if(i == 0) {
				arrays += "\tsgemv_(&trans, &m, &n, &alpha, W"+i+", &m, input, &incx, &beta, b"+i+", &incy); // Layer - first - index " + i + "\n"; 
				arrays += "\tactivation(b"+i+", m, \"" + activationList.get(i).toString() + "\");\n\n";
			}else if(i == totalLayers-1) {
				arrays += "\tsgemv_(&trans, &m, &n, &alpha, W"+i+", &m, b"+(i-1)+", &incx, &beta, output, &incy); // Layer - last - index " + i + "\n";
				arrays += "\tactivation(output, m, \"" + activationList.get(i).toString() + "\");\n\n";
			}else {
				arrays += "\tsgemv_(&trans, &m, &n, &alpha, W"+i+", &m, b"+(i-1)+", &incx, &beta, b"+i+", &incy); // Layer - middle - index " + i + "\n";
				arrays += "\tactivation(b"+i+", m, \"" + activationList.get(i).toString() + "\");\n\n";
			}
		}
		
		/*
		 * Now write the whole .c file
		 */
		String functionEnd = "}";
		absolutPath = cPath + modelName + "/" + modelName + ".c";
		fileHandler.writeTextTo(absolutPath, comment + include + functionStart + blasParameters + arrays + functionEnd);	
	}

	/**
	 * This method will evaluate the model. 
	 * From the data iteration set, we select a random data set and evaluate it
	 */
	private void evaluateModel() {
		/*
		 * Do a quick check!
		 */
		if(dL4JModel.getDL4JSerializableConfiguration().getModelName() == null)
			return;
		if(dL4JModel.getDL4JData().getTrainDataSetIterator() == null)
			return;
		
		/*
		 * Clear first the text box and the progressBar
		 */
		textArea.clear();
		progressBar.setProgress(0);
		
		/*
		 * Reset our main data for both resetting train and eval objects of data iteration sets
		 */
		dL4JModel.getDL4JData().getDataSetIterator().reset();
		
		/*
		 * Get the data set from a random batch inside data set iteration
		 */
		DataSetIterator dataTrainSetIterator = dL4JModel.getDL4JData().getTrainDataSetIterator();
		DataSet dataTrainSet = dataTrainSetIterator.next();
		
		/*
		 * Get model and its evaluation
		 */
		MultiLayerNetwork multiLayerNetwork = dL4JModel.getMultiLayerNetwork();
		RegressionEvaluation regressionEvaluation;
		Evaluation evaluation;
		
		/*
		 * Do we have regression or classification data?
		 */
		boolean regression = dL4JModel.getDL4JData().isRegression();
		try {
			if(regression == true) {
				/*
				 * Do a test for regression and print it out
				 */
				regressionEvaluation = multiLayerNetwork.evaluateRegression(dataTrainSetIterator);
				INDArray output = multiLayerNetwork.output(dataTrainSet.getFeatures());
				regressionEvaluation.eval(dataTrainSet.getLabels(), output);
				String status = regressionEvaluation.stats();
				textArea.setText(status);
			}else {
				/*
				 * Do a test for classification and print it out 
				 */
				evaluation = multiLayerNetwork.evaluate(dataTrainSetIterator);
				INDArray output = multiLayerNetwork.output(dataTrainSet.getFeatures());
				evaluation.eval(dataTrainSet.getLabels(), output);
				String status = evaluation.stats();
				textArea.setText(status);
			}
		}catch(IllegalStateException | IllegalArgumentException e) {
			dialogs.exception("Cannot evaluate the model.", e);
		}
	}

	/**
	 * Train our model!
	 */
	private void trainModel() {
		/*
		 * Do a quick check!
		 */
		if(dL4JModel.getDL4JSerializableConfiguration().getModelName() == null)
			return;
		if(dL4JModel.getDL4JData().getTrainDataSetIterator() == null)
			return;
		
		/*
		 * Reset our main data for both resetting train and eval objects of data iteration sets
		 */
		dL4JModel.getDL4JData().getDataSetIterator().reset();
		
		/*
		 * Ask for a epoch number! Minimum is 0
		 */
		int epochs = 0;
		try {
			String epochsString = dialogs.input("Epochs", "Enter (int)epochs for training?");
			if(epochsString.equals("") == true) // This will prevent so if we press "cancel", nothing happens else than the dialog disappear
				return; 
			epochs = Integer.parseInt(epochsString);
			if(epochs < 0) {
				dialogs.alertDialog(AlertType.INFORMATION, "Zero", "You cannot have 0 epochs!");
				return;
			}
		}catch(NumberFormatException e) {
			dialogs.exception("Cannot convert that text into an integer number!", e);
			return;
		}
		
		/*
		 * Create our thread object and start it. When we start it, then the BUILD icon changes to STOP icon
		 */
		continueLoop.set(true);
		textArea.clear();
		progressBar.setProgress(0);
		DL4JThread dL4JThread = new DL4JThread(dL4JModel.getMultiLayerNetwork(), dL4JModel.getDL4JData().getTrainDataSetIterator(), textArea, progressBar, continueLoop, epochs);
		appBar.getActionItems().remove(0);
		appBar.getActionItems().add(0, MaterialDesignIcon.STOP.button(e -> stopTrain()));
		dL4JThread.start();
	}

	/**
	 * This method will stop the thread and then change back to BUILD icon 
	 */
	private void stopTrain() {
		continueLoop.set(false);
		appBar.getActionItems().remove(0);
		appBar.getActionItems().add(0, MaterialDesignIcon.BUILD.button(e -> trainModel()));
	}
}
